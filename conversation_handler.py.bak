"""
Conversation Handler Atualizado - Integra o sistema de 20 perguntas com an√°lise completa
"""

import logging
import json
from typing import Dict, Any
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    CallbackQueryHandler,
    filters,
)

# Importar os m√≥dulos LLM existentes
from llm_handler.grok_handler import GrokHandler


# Importar o novo sistema de an√°lise
from main_integration import PostAnalysisHandler

# Estados do question√°rio
(
    AGUARDANDO_NOME,
    AGUARDANDO_RESPOSTA_1,
    AGUARDANDO_RESPOSTA_2,
    AGUARDANDO_RESPOSTA_3,
    AGUARDANDO_RESPOSTA_4,
    AGUARDANDO_RESPOSTA_5,
    AGUARDANDO_RESPOSTA_6,
    AGUARDANDO_RESPOSTA_7,
    AGUARDANDO_RESPOSTA_8,
    AGUARDANDO_RESPOSTA_9,
    AGUARDANDO_RESPOSTA_10,
    AGUARDANDO_RESPOSTA_11,
    AGUARDANDO_RESPOSTA_12,
    AGUARDANDO_RESPOSTA_13,
    AGUARDANDO_RESPOSTA_14,
    AGUARDANDO_RESPOSTA_15,
    AGUARDANDO_RESPOSTA_16,
    AGUARDANDO_RESPOSTA_17,
    AGUARDANDO_RESPOSTA_18,
    AGUARDANDO_RESPOSTA_19,
    AGUARDANDO_RESPOSTA_20,
    ANALISE_FINALIZADA,
) = range(22)

# Configurar logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[logging.FileHandler("bot_contabil.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)


class ConversationHandlerBot:
    """Handler principal para o bot cont√°bil com an√°lise completa"""

    def __init__(self):
        self.grok = GrokHandler()
        # ‚úÖ NOVA INTEGRA√á√ÉO - Sistema de an√°lise p√≥s-question√°rio
        self.post_analysis = PostAnalysisHandler()

        # Perguntas do question√°rio empresarial
        self.perguntas = [
            {
                "pergunta": "üè¢ Qual o nome da sua empresa?",
                "chave": "nome_empresa",
                "tipo": "texto",
            },
            {
                "pergunta": "üìä Qual o faturamento anual aproximado da empresa? (em R$)",
                "chave": "faturamento_anual",
                "tipo": "numero",
                "opcoes": [
                    "At√© 360mil",
                    "360mil - 4.8mi",
                    "4.8mi - 78mi",
                    "Acima 78mi",
                ],
            },
            {
                "pergunta": "üë• Quantos funcion√°rios a empresa possui?",
                "chave": "num_funcionarios",
                "tipo": "numero",
            },
            {
                "pergunta": "üè≠ Qual a atividade principal da empresa?",
                "chave": "atividade_principal",
                "tipo": "texto",
                "opcoes": [
                    "Com√©rcio",
                    "Servi√ßos",
                    "Ind√∫stria",
                    "Agroneg√≥cio",
                    "Outros",
                ],
            },
            {
                "pergunta": "‚è∞ A empresa tem hist√≥rico de atrasos em obriga√ß√µes fiscais?",
                "chave": "atraso_obrigacoes",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "√Äs vezes"],
            },
            {
                "pergunta": "üìù A maioria dos processos cont√°beis s√£o feitos manualmente?",
                "chave": "controle_manual",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Parcialmente"],
            },
            {
                "pergunta": "üìÑ A empresa emite muitas notas fiscais por m√™s? (+100)",
                "chave": "volume_nfs_alto",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o"],
            },
            {
                "pergunta": "üíª Usa sistema cont√°bil integrado (ERP)?",
                "chave": "usa_sistema_integrado",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Sistema b√°sico"],
            },
            {
                "pergunta": "üò∞ A equipe cont√°bil est√° sobrecarregada?",
                "chave": "equipe_sobrecarregada",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "√Äs vezes"],
            },
            {
                "pergunta": "üè¶ Tem dificuldades na concilia√ß√£o banc√°ria?",
                "chave": "dificuldade_conciliacao",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "√Äs vezes"],
            },
            {
                "pergunta": "üìä Gera relat√≥rios gerenciais regularmente?",
                "chave": "gera_relatorios",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Raramente"],
            },
            {
                "pergunta": "üîê Tem controles internos bem definidos?",
                "chave": "controles_internos",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Parcialmente"],
            },
            {
                "pergunta": "üíæ Faz backup dos dados regularmente?",
                "chave": "backups_regulares",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "√Äs vezes"],
            },
            {
                "pergunta": "üìã Os processos est√£o documentados?",
                "chave": "processos_documentados",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Parcialmente"],
            },
            {
                "pergunta": "üéì A equipe recebe treinamento regular?",
                "chave": "equipe_treinada",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "Raramente"],
            },
            {
                "pergunta": "üìÖ Tem prazo fiscal pr√≥ximo (ECF, SPED, etc.)?",
                "chave": "prazo_fiscal_proximo",
                "tipo": "boolean",
                "opcoes": ["Sim", "N√£o", "N√£o sei"],
            },
            {
                "pergunta": "‚ö° Qual seria a prioridade m√°xima para automatizar?",
                "chave": "prioridade_automacao",
                "tipo": "texto",
                "opcoes": [
                    "Lan√ßamentos NF-e",
                    "Concilia√ß√£o banc√°ria",
                    "Folha pagamento",
                    "Relat√≥rios",
                    "SPED/Fiscal",
                ],
            },
            {
                "pergunta": "üí∞ Qual or√ßamento mensal dispon√≠vel para automa√ß√£o?",
                "chave": "orcamento_automacao",
                "tipo": "numero",
                "opcoes": ["At√© R$ 2mil", "R$ 2-5mil", "R$ 5-10mil", "Acima R$ 10mil"],
            },
            {
                "pergunta": "‚è±Ô∏è Em quanto tempo gostaria de ver resultados?",
                "chave": "prazo_resultados",
                "tipo": "texto",
                "opcoes": ["30 dias", "60 dias", "90 dias", "6 meses"],
            },
            {
                "pergunta": "üéØ Qual o principal objetivo com as automa√ß√µes?",
                "chave": "objetivo_principal",
                "tipo": "texto",
                "opcoes": [
                    "Reduzir custos",
                    "Ganhar tempo",
                    "Reduzir erros",
                    "Crescer sem contratar",
                    "Compliance fiscal",
                ],
            },
        ]

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Inicia o question√°rio"""
        user = update.effective_user

        # Limpar dados anteriores
        context.user_data.clear()
        context.user_data["respostas_questionario"] = {}
        context.user_data["pergunta_atual"] = 0

        logger.info(f"Usu√°rio {user.id} iniciou question√°rio")

        await update.message.reply_text(
            f"üëã Ol√° {user.first_name}! Sou a **Maria**, sua t√©cnica cont√°bil virtual!\n\n"
            "üéØ Vou fazer 20 perguntas para criar um **diagn√≥stico completo** da sua empresa "
            "e sugerir automa√ß√µes personalizadas.\n\n"
            "üìä Ao final, voc√™ receber√°:\n"
            "‚Ä¢ An√°lise detalhada da situa√ß√£o atual\n"
            "‚Ä¢ Plano de a√ß√£o com cronograma\n"
            "‚Ä¢ C√°lculo de ROI e economia estimada\n"
            "‚Ä¢ Cronograma de implementa√ß√£o\n\n"
            "‚è±Ô∏è Leva apenas 5 minutos. Vamos come√ßar?\n\n"
            f"**PERGUNTA 1/20**\n{self.perguntas[0]['pergunta']}",
            parse_mode="Markdown",
        )

        return AGUARDANDO_NOME

    async def processar_resposta(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        """Processa cada resposta e avan√ßa para pr√≥xima pergunta"""

        pergunta_atual = context.user_data.get("pergunta_atual", 0)
        resposta = update.message.text

        # Salvar resposta
        chave = self.perguntas[pergunta_atual]["chave"]
        context.user_data["respostas_questionario"][chave] = resposta

        # Log da resposta
        logger.info(f"Pergunta {pergunta_atual + 1}: {chave} = {resposta}")

        # Avan√ßar para pr√≥xima pergunta
        pergunta_atual += 1
        context.user_data["pergunta_atual"] = pergunta_atual

        # Verificar se terminaram as perguntas
        if pergunta_atual >= len(self.perguntas):
            # ‚úÖ NOVA FUNCIONALIDADE - Processar an√°lise completa
            await self.finalizar_questionario(update, context)
            return ANALISE_FINALIZADA

        # Mostrar pr√≥xima pergunta
        pergunta_data = self.perguntas[pergunta_atual]

        # Criar teclado se h√° op√ß√µes
        reply_markup = None
        if "opcoes" in pergunta_data:
            keyboard = [[KeyboardButton(opcao)] for opcao in pergunta_data["opcoes"]]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, one_time_keyboard=True, resize_keyboard=True
            )

        await update.message.reply_text(
            f"‚úÖ Resposta registrada!\n\n"
            f"**PERGUNTA {pergunta_atual + 1}/20**\n"
            f"{pergunta_data['pergunta']}",
            reply_markup=reply_markup,
            parse_mode="Markdown",
        )

        # Retornar estado baseado na pergunta atual
        return AGUARDANDO_RESPOSTA_1 + pergunta_atual - 1

    async def finalizar_questionario(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """‚úÖ NOVA FUN√á√ÉO - Finaliza question√°rio e inicia an√°lise completa"""

        # Remover teclado
        await update.message.reply_text(
            "‚úÖ **Question√°rio finalizado!**\n\n"
            "ü§ñ Agora vou analisar todas as suas respostas e criar um diagn√≥stico completo da sua empresa...",
            reply_markup=ReplyKeyboardRemove(),
            parse_mode="Markdown",
        )

        # ‚úÖ INTEGRA√á√ÉO PRINCIPAL - Chamar sistema de an√°lise
        await self.post_analysis.processar_respostas_completas(update, context)

    async def reset(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Reset do question√°rio"""
        context.user_data.clear()

        await update.message.reply_text(
            "üîÑ Question√°rio resetado!\n\nDigite /start para come√ßar novamente.",
            reply_markup=ReplyKeyboardRemove(),
        )

        return ConversationHandler.END

    async def cancelar(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Cancela o question√°rio"""
        await update.message.reply_text(
            "‚ùå Question√°rio cancelado.\n\n"
            "Digite /start quando quiser fazer o diagn√≥stico.",
            reply_markup=ReplyKeyboardRemove(),
        )

        return ConversationHandler.END

    async def status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostra status atual do question√°rio"""
        pergunta_atual = context.user_data.get("pergunta_atual", 0)
        total_respostas = len(context.user_data.get("respostas_questionario", {}))

        await update.message.reply_text(
            f"üìä **Status do Question√°rio**\n\n"
            f"‚Ä¢ Pergunta atual: {pergunta_atual + 1}/20\n"
            f"‚Ä¢ Respostas coletadas: {total_respostas}\n"
            f"‚Ä¢ Progresso: {int((total_respostas / 20) * 100)}%\n\n"
            "Digite /reset para recome√ßar ou continue respondendo.",
            parse_mode="Markdown",
        )

    async def ajuda(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostra ajuda"""
        await update.message.reply_text(
            "üÜò **AJUDA - Bot T√©cnico Cont√°bil**\n\n"
            "üìã **Comandos dispon√≠veis:**\n"
            "/start - Iniciar diagn√≥stico empresarial\n"
            "/status - Ver progresso atual\n"
            "/reset - Recome√ßar question√°rio\n"
            "/cancel - Cancelar question√°rio\n"
            "/ajuda - Esta mensagem\n\n"
            "üéØ **Como funciona:**\n"
            "1. Respondo 20 perguntas sobre sua empresa\n"
            "2. Recebo an√°lise completa autom√°tica\n"
            "3. Vejo plano de automa√ß√£o personalizado\n"
            "4. Obtenho cronograma e c√°lculos de ROI\n\n"
            "‚è±Ô∏è Tempo: ~5 minutos\n"
            "üìä Resultado: Diagn√≥stico profissional completo",
            parse_mode="Markdown",
        )

    def get_conversation_handler(self) -> ConversationHandler:
        """Retorna o ConversationHandler configurado"""

        states = {
            AGUARDANDO_NOME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, self.processar_resposta)
            ],
        }

        # Adicionar estados para cada pergunta
        for i in range(1, 20):
            state_name = AGUARDANDO_RESPOSTA_1 + i - 1
            states[state_name] = [
                MessageHandler(filters.TEXT & ~filters.COMMAND, self.processar_resposta)
            ]

        # Estado final
        states[ANALISE_FINALIZADA] = [
            MessageHandler(
                filters.TEXT & ~filters.COMMAND, self.post_analysis.callback_handler
            )
        ]

        return ConversationHandler(
            entry_points=[CommandHandler("start", self.start)],
            states=states,
            fallbacks=[
                CommandHandler("cancel", self.cancelar),
                CommandHandler("reset", self.reset),
                CommandHandler("status", self.status),
                CommandHandler("ajuda", self.ajuda),
            ],
            per_user=True,
            per_chat=True,
        )


# ‚úÖ FUN√á√ïES AUXILIARES PARA INTEGRA√á√ÉO
def create_application():
    """Cria e configura a aplica√ß√£o do bot"""
    from config import TELEGRAM_BOT_TOKEN

    # Criar aplica√ß√£o
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Criar handler principal
    conversation_bot = ConversationHandlerBot()

    # ‚úÖ REGISTRAR HANDLERS
    # 1. Conversation handler para question√°rio
    application.add_handler(conversation_bot.get_conversation_handler())

    # 2. ‚úÖ NOVO - Callback handler para bot√µes p√≥s-an√°lise
    application.add_handler(
        CallbackQueryHandler(conversation_bot.post_analysis.callback_handler)
    )

    # 3. Comandos gerais
    application.add_handler(CommandHandler("ajuda", conversation_bot.ajuda))
    application.add_handler(CommandHandler("status", conversation_bot.status))

    logger.info("‚úÖ Bot configurado com sistema de an√°lise completa!")

    return application


if __name__ == "__main__":
    # Teste direto
    app = create_application()
    print("ü§ñ Bot T√©cnico Cont√°bil Virtual iniciado!")
    print("‚úÖ Sistema de an√°lise p√≥s-question√°rio ativo!")
    app.run_polling()
